from skimage import ioimport openslidefrom openslide import ImageSlide, open_slidefrom openslide.deepzoom import DeepZoomGeneratorimport osfrom PIL import Imageimport sysimage_scope_coords = Trueif(len(sys.argv) > 2):    dir_ = sys.argv[1]    file_ = sys.argv[2]else:    dir_ = '/Users/sarahkeegan/fenyolab/data_and_results/Pathology/HipInfection' #'C:/Projects/Pathology'    file_ = 'ImageCollection_0000026276_2016-10-27 13_45_02.scn'    #'ImageCollection_0000026276_2016-10-27 13_45_02.scn'    #'ImageCollection_0000026277_2016-10-27 14_06_08.scn'    #'ImageCollection_0000026278_2016-10-27 13_45_30.scn'    #'ImageCollection_0000026279_2016-10-27 14_07_46.scn'    #"ImageCollection_0000026280_2016-10-27 14_13_01.scn"    if(len(sys.argv) > 5):    col_x = int(sys.argv[3])    row_y = int(sys.argv[4])    side_len = int(sys.argv[5])else:    #produce all tiles, not given a specific slice    col_x = 71730  #85480 #78980 #0    row_y = 62340 #66800 #0    side_len = 7500 #0    file_pre = os.path.splitext(file_)[0]slide = openslide.OpenSlide(dir_ + '/' + file_)print 'Opened slide...'print 'Vendor: ' + slide.properties['openslide.vendor']print 'Zoom levels: ' + slide.properties['openslide.level-count']print 'Largest region will be read and saved as tiff (tiles).  Any further regions will be ignored.  Entire slide will also be saved.'print 'If given an x,y coordinate and dimensions (width,height), then only this slice will be outputted.'#read entire slide, 2nd lowest zoom level, and save.level_count = int(slide.properties['openslide.level-count'])level = level_count-3 # 3rd zoom levelimage_ = slide.read_region(            (0,0),            level,            (int(slide.properties['openslide.level['+str(level)+'].width']),int(slide.properties['openslide.level['+str(level)+'].height'])))image_.save(dir_ + '/' + file_pre + '__FullSlide.tif')#read region sizes and get largest regionregion_count = 0max_region_i = 0max_region_size = 0x_min_regions = -1y_max_regions = -1while(True):    try:        region_width = int(slide.properties['openslide.region['+str(region_count)+'].width'])        region_height = int(slide.properties['openslide.region['+str(region_count)+'].height'])        region_x = int(slide.properties['openslide.region['+str(region_count)+'].x'])        region_y = int(slide.properties['openslide.region['+str(region_count)+'].y'])                #print "region " + str(region_count)        #print "size = " + str(region_width * region_height)        if(region_width * region_height > max_region_size):            max_region_size = region_width * region_height            max_region_i = region_count        region_count += 1        if(x_min_regions == -1 or region_x < x_min_regions):            x_min_regions = region_x        if(region_y+region_height > y_max_regions):            y_max_regions = region_y+region_height    except KeyError:        breakprint "region_count = " + str(region_count)#print "max region size = " + str(max_region_size)#print "max region i = " + str(max_region_i)region_width = int(slide.properties['openslide.region['+str(max_region_i)+'].width'])region_height = int(slide.properties['openslide.region['+str(max_region_i)+'].height'])region_x = int(slide.properties['openslide.region['+str(max_region_i)+'].x'])region_y = int(slide.properties['openslide.region['+str(max_region_i)+'].y'])image_height = int(slide.properties['openslide.level[0].height'])#if outputting specific slice given by user, do below:error = Falseif(side_len > 0):    if(image_scope_coords):         #coords from leica are cropped coords, correct for this        #image rotated 90 degrees to the left from leica software viewer, adjust coords        new_x = row_y+(x_min_regions)        new_y = image_height-(col_x+(image_height-y_max_regions))                col_x = new_x        row_y = new_y                #uppper left corner is now upper right corner, fix        row_y = row_y-side_len            #region width/height, dimensions    if(col_x < region_x):        print '**Start x coordinate < start of region, x-coordinate of output slice will begin at start of region.'        col_x = region_x    if(row_y < region_y):        print '**Start y coordinate < start of region, y-coordinate of output slice will begin at start of region.'        row_y = region_y    if(col_x >= region_x + region_width):        print '**Start x coordinate > end of region, ending program.'        error = True    if(row_y >= region_y + region_height):        print '**Start y coordinate > end of region, ending program'        error = True    if(not error):        tile = slide.read_region((col_x,row_y),0,(side_len,side_len))        if(image_scope_coords):            #rotate to match ImageScope            tile_ = tile.rotate(-90, expand=1)        tile.save(dir_ + '/' + file_pre + '__Slice_' + str(col_x)+'_'+str(row_y)+'_'+str(side_len)+'.tif')        tile_.save(dir_ + '/' + file_pre + '__Slice_' + str(col_x)+'_'+str(row_y)+'_'+str(side_len)+'.R.tif')        del tile   #if outputting all tiles, do below:else:    #get deep zoom tiles, save    overlap = 0 # 1    tile_size=2**13-overlap*2    zoomed_slide = DeepZoomGenerator(slide, tile_size=tile_size, overlap=overlap, limit_bounds=False)        print zoomed_slide.level_count    print    print zoomed_slide.tile_count    print    print zoomed_slide.level_tiles    print    print zoomed_slide.level_dimensions    print        last_level = int(zoomed_slide.level_count-1)    ##view_level = last_level    ##level_mult = float(slide.properties['openslide.level['+str(?)+'].downsample'])        #num_cols = zoomed_slide.level_tiles[last_level][0]    #num_rows = zoomed_slide.level_tiles[last_level][1]        #start at beginning of region 0        start_col = region_x/tile_size    start_row = region_y/tile_size    num_cols = region_width/tile_size+1    num_rows = region_height/tile_size+1        #start_col = 11    #start_row = 15    #num_cols = 1    #num_rows = 7        print start_col    print start_row    print num_cols    print num_rows    print    output_tiles = True        row_tiles_per_image = 2    col_tiles_per_image = 2        if not os.path.isdir(dir_ + '/' + file_pre + '__tiles'):        os.mkdir(dir_ + '/' + file_pre + '__tiles')    for col in range(start_col,start_col+num_cols):        for row in range(start_row,start_row+num_rows):            print 'Saving ' + str(col) + ',' + str(row)            tile = zoomed_slide.get_tile(last_level,(col,row))            tile.save(dir_ + '/' + file_pre + '__tiles/' + file_pre + '__Tile_' + str(col) + '_' + str(row) + '.tif')            del tile